---
title: MessageBox
description: Simple modal dialog system with async support and object pooling
icon: MessageSquare
---

<Callout type="warn" title="Namespace changed in v1.1">
MessageBox moved from `JEngine.Core.Misc` to `JEngine.UI` and is now in the separate `jengine.ui` package. Install it via `openupm add com.jasonxudeveloper.jengine.ui` ([OpenUPM](https://openupm.com/packages/com.jasonxudeveloper.jengine.ui/)).
</Callout>

JEngine provides a simple and practical MessageBox system that supports asynchronous operations and object pooling optimization.

## Basic Usage

### Show Confirmation Dialog
```csharp
// Show confirmation dialog and wait for user choice
bool result = await MessageBox.Show("Confirm", "Do you want to delete this file?");
if (result)
{
    Debug.Log("User clicked confirm");
}
else
{
    Debug.Log("User clicked cancel");
}
```

### Custom Button Text
```csharp
// Customize confirm and cancel button text
bool result = await MessageBox.Show("Save", "Save current changes?", "Save", "Discard");
if (result)
{
    Debug.Log("User chose to save");
}
```

### Show Only Confirm Button
```csharp
// Show only confirm button (omit cancel button text)
bool result = await MessageBox.Show("Notice", "Operation completed!", "OK");
// Return value is always true since there's only one button
```

## Complete API

### Show Method
Display a modal dialog box with customizable title, content, and button text.

```csharp
public static UniTask<bool> Show(string title, string content, string ok = "OK", string no = "Cancel")
```

**Parameters:**
- `title` - MessageBox title
- `content` - MessageBox content
- `ok` - Confirm button text (default "OK")
- `no` - Cancel button text (default "Cancel", if empty only show confirm button)

**Return Value:**
- `UniTask<bool>` - Returns `true` if user clicks confirm, `false` if user clicks cancel

## Management Methods

### CloseAll Method
Force close all currently displayed message boxes, typically used for scene transitions or emergency situations.

```csharp
// Force close all currently displayed message boxes
MessageBox.CloseAll();
```

### Dispose Method
Clean up all message box instances and object pool, release related resources, typically called when application exits.

```csharp
// Clean up all message box instances and object pool
MessageBox.Dispose();
```

## Status Query

### Get Active Count
Get the number of currently displayed message boxes, used for debugging and status monitoring.

```csharp
// Get the number of currently displayed message boxes
int activeCount = MessageBox.ActiveCount;
Debug.Log($"Currently {activeCount} message boxes are displayed");
```

### Get Pooled Count
Get the number of message box instances cached in the object pool, used for performance analysis and memory management.

```csharp
// Get the number of message boxes in object pool
int pooledCount = MessageBox.PooledCount;
Debug.Log($"There are {pooledCount} message box instances in the pool");
```

## Usage Examples

<Tabs items={['Delete Confirmation', 'Success Notice', 'Batch Operations']}>
<Tab value="Delete Confirmation">
```csharp
public async void DeleteFile()
{
    bool confirmed = await MessageBox.Show("Delete Confirmation", "Are you sure you want to delete this file?", "Delete", "Cancel");
    if (confirmed)
    {
        File.Delete(filePath);
        Debug.Log("File deleted");
    }
}
```
</Tab>
<Tab value="Success Notice">
```csharp
public async void ShowSuccessMessage()
{
    // Show notice with only confirm button
    await MessageBox.Show("Success", "Operation completed!", "OK");
    Debug.Log("User acknowledged");
}
```
</Tab>
<Tab value="Batch Operations">
```csharp
public async void ProcessMultipleItems()
{
    for (int i = 0; i < items.Count; i++)
    {
        bool shouldContinue = await MessageBox.Show(
            "Process Confirmation",
            $"Process item {i + 1}?",
            "Process",
            "Skip"
        );
        if (shouldContinue) ProcessItem(items[i]);
    }
}
```
</Tab>
</Tabs>

## Best Practices

<Accordions>
<Accordion title="Performance Optimization">
- MessageBox uses object pooling system to automatically reuse instances
- No need to manually manage message box lifecycle
</Accordion>

<Accordion title="User Experience">
- Provide confirmation dialogs for important operations
- Use clear and explicit button text
- Avoid frequent popups that interrupt user experience
</Accordion>

<Accordion title="Asynchronous Handling">
```csharp
// Recommended: Use async/await
public async void HandleUserChoice()
{
    bool result = await MessageBox.Show("Confirm", "Continue operation?");
    if (result) { /* Handle confirmation */ }
}

// Not recommended: Blocking main thread
public void HandleUserChoiceBlocking()
{
    var task = MessageBox.Show("Confirm", "Continue operation?");
    bool result = task.GetAwaiter().GetResult(); // May cause lag
}
```
</Accordion>
</Accordions>

<Callout type="warn" title="Important Notes">
- MessageBox is based on UniTask - ensure UniTask is properly configured
- MessageBox prevents user interaction with other UI while displayed
- Multiple message boxes can be displayed but avoid overlapping through logic control
- Visual style is controlled by Unity UI prefabs - customize by modifying the prefab
</Callout>