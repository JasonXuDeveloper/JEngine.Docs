---
title: 弹窗提示框
description: 简洁实用的模态对话框系统，支持异步和对象池优化
icon: MessageSquare
---

<Callout type="warn" title="v1.1 命名空间变更">
MessageBox 从 `JEngine.Core.Misc` 迁移至 `JEngine.UI`，现位于独立的 `jengine.ui` 包中。通过 `openupm add com.jasonxudeveloper.jengine.ui` 安装（[OpenUPM 页面](https://openupm.com/packages/com.jasonxudeveloper.jengine.ui/)）。
</Callout>

JEngine 提供了一个简洁实用的弹窗提示框（MessageBox）系统，支持异步操作和对象池优化。

## 基本使用

### 显示确认对话框
```csharp
// 显示确认对话框，等待用户选择
bool result = await MessageBox.Show("确认", "是否删除该文件？");
if (result)
{
    Debug.Log("用户点击了确认");
}
else
{
    Debug.Log("用户点击了取消");
}
```

### 自定义按钮文本
```csharp
// 自定义确认和取消按钮的文本
bool result = await MessageBox.Show("保存", "是否保存当前修改？", "保存", "放弃");
if (result)
{
    Debug.Log("用户选择保存");
}
```

### 只显示确认按钮
```csharp
// 只显示确认按钮（省略取消按钮文本）
bool result = await MessageBox.Show("提示", "操作完成！", "确定");
// 返回值始终为 true，因为只有一个按钮
```

## 完整 API

### Show 方法
显示一个模态弹窗对话框，支持自定义标题、内容和按钮文本。

```csharp
public static UniTask<bool> Show(string title, string content, string ok = "OK", string no = "Cancel")
```

**参数说明：**
- `title` - 弹窗标题
- `content` - 弹窗内容
- `ok` - 确认按钮文本（默认 "OK"）
- `no` - 取消按钮文本（默认 "Cancel"，如果为空则只显示确认按钮）

**返回值：**
- `UniTask<bool>` - 用户点击确认返回 `true`，点击取消返回 `false`

## 管理方法

### CloseAll 方法
强制关闭所有当前显示的弹窗，通常用于场景切换或紧急情况。

```csharp
// 强制关闭所有当前显示的弹窗
MessageBox.CloseAll();
```

### Dispose 方法
清理所有弹窗实例和对象池，释放相关资源，通常在应用程序退出时调用。

```csharp
// 清理所有弹窗实例和对象池
MessageBox.Dispose();
```

## 状态查询

### ActiveCount 属性
获取当前正在显示的弹窗数量，用于调试和状态监控。

```csharp
// 获取当前显示的弹窗数量
int activeCount = MessageBox.ActiveCount;
Debug.Log($"当前有 {activeCount} 个弹窗正在显示");
```

### PooledCount 属性
获取对象池中缓存的弹窗实例数量，用于性能分析和内存管理。

```csharp
// 获取对象池中的弹窗数量
int pooledCount = MessageBox.PooledCount;
Debug.Log($"对象池中有 {pooledCount} 个弹窗实例");
```

## 使用示例

<Tabs items={['删除确认', '成功提示', '批量操作']}>
<Tab value="删除确认">
```csharp
public async void DeleteFile()
{
    bool confirmed = await MessageBox.Show("删除确认", "确定要删除这个文件吗？", "删除", "取消");
    if (confirmed)
    {
        File.Delete(filePath);
        Debug.Log("文件已删除");
    }
}
```
</Tab>
<Tab value="成功提示">
```csharp
public async void ShowSuccessMessage()
{
    // 只显示确认按钮的提示
    await MessageBox.Show("成功", "操作已完成！", "确定");
    Debug.Log("用户已确认");
}
```
</Tab>
<Tab value="批量操作">
```csharp
public async void ProcessMultipleItems()
{
    for (int i = 0; i < items.Count; i++)
    {
        bool shouldContinue = await MessageBox.Show(
            "处理确认",
            $"是否处理第 {i + 1} 个项目？",
            "处理",
            "跳过"
        );
        if (shouldContinue) ProcessItem(items[i]);
    }
}
```
</Tab>
</Tabs>

## 最佳实践

<Accordions>
<Accordion title="性能优化">
- MessageBox 使用对象池系统，自动复用实例
- 无需手动管理弹窗的生命周期
</Accordion>

<Accordion title="用户体验">
- 为重要操作提供确认对话框
- 使用清晰明确的按钮文本
- 避免频繁弹窗打扰用户体验
</Accordion>

<Accordion title="异步处理">
```csharp
// 推荐：使用 async/await
public async void HandleUserChoice()
{
    bool result = await MessageBox.Show("确认", "继续操作？");
    if (result) { /* 处理确认逻辑 */ }
}

// 不推荐：阻塞主线程
public void HandleUserChoiceBlocking()
{
    var task = MessageBox.Show("确认", "继续操作？");
    bool result = task.GetAwaiter().GetResult(); // 可能导致卡顿
}
```
</Accordion>
</Accordions>

<Callout type="warn" title="注意事项">
- MessageBox 基于 UniTask - 确保项目中已正确配置
- 弹窗显示期间会阻止用户与其他 UI 交互
- 同时可以显示多个弹窗，但建议通过逻辑控制避免重叠显示
- 视觉样式由 Unity UI 预制体控制 - 可通过修改预制体自定义外观
</Callout>