---
title: JAction 链式任务
description: 支持零GC异步执行的链式任务框架
icon: Zap
---

链式操作框架，用于构建顺序和并行任务流水线，支持零GC的异步执行。

## 概述

JAction 是一个流畅的 API，用于在 Unity 中组合复杂的操作序列。它支持：

- **链式方法** - 构建可读的操作流水线
- **延迟和等待** - 时间延迟、帧延迟、条件等待
- **循环** - 带条件的重复模式
- **并行执行** - 同时运行多个操作
- **零GC异步** - 自定义 awaitable 结构体实现无GC的 async/await
- **对象池** - 自动回收 JAction 实例

<Callout type="info" title="可抢占执行">
JAction 是**可抢占的** - 它可以在任何让出点（延迟、等待、帧边界）被中断或取消。但是，**`.Do()` 回调中的原子操作无法被抢占**。如果您的回调包含阻塞操作（例如同步 I/O、无限循环或长时间计算），它将阻塞主线程直到完成。

请始终保持 `.Do()` 回调轻量且非阻塞，以确保响应性。
</Callout>

## 安装

<Tabs items={['OpenUPM CLI', 'Unity Package Manager']}>
<Tab value="OpenUPM CLI">
```bash
openupm add com.jasonxudeveloper.jengine.util
```
</Tab>
<Tab value="Unity Package Manager">
如需通过 Unity 的 Package Manager 手动安装，请访问 [OpenUPM 页面](https://openupm.com/packages/com.jasonxudeveloper.jengine.util/) 并按照说明操作。
</Tab>
</Tabs>

### 命名空间

```csharp
using JEngine.Util;
```

## 快速开始

```csharp
// 基本异步序列（推荐）
using var action = await JAction.Create()
    .Do(static () => Debug.Log("步骤 1"))
    .Delay(1f)
    .Do(static () => Debug.Log("步骤 2"))
    .ExecuteAsync();

// 带超时
using var action2 = await JAction.Create()
    .Do(static () => Debug.Log("Hello"))
    .Delay(2f)
    .ExecuteAsync(timeout: 5f);
```

## 执行方法

| 方法 | 描述 |
|------|------|
| `.Execute(float timeout = 0)` | 同步执行（阻塞主线程直到完成） |
| `.ExecuteAsync(float timeout = 0)` | 通过 PlayerLoop 异步执行（推荐） |

<Callout type="error" title="推荐使用 ExecuteAsync() 以获得更好的性能">
**`Execute()` 通过在 while 循环中自旋来阻塞主线程。** 这会导致：
- 掉帧和卡顿
- 执行期间 UI 冻结
- 输入延迟
- 移动端可能出现 ANR（应用无响应）

**除非您特别需要阻塞行为**（例如在单元测试或编辑器脚本中），**否则请始终使用 `ExecuteAsync()`**。
</Callout>

### 同步 vs 异步对比

```csharp
// 不好：阻塞主线程 - 会导致 2 秒的冻结！
using var action1 = JAction.Create()
    .Do(static () => Debug.Log("开始"))
    .Delay(2f)  // 自旋 2 秒，阻塞一切
    .Do(static () => Debug.Log("结束"))
    .Execute();

// 好：非阻塞 - 游戏继续流畅运行
using var action2 = await JAction.Create()
    .Do(static () => Debug.Log("开始"))
    .Delay(2f)  // 让出给 PlayerLoop，无阻塞
    .Do(static () => Debug.Log("结束"))
    .ExecuteAsync();
```

### 使用 `using` 自动释放

`JAction` 实现了 `IDisposable`，所以可以对 `Execute()` 和 `ExecuteAsync()` 使用 `using` 模式：

```csharp
// 同步执行带自动释放
using var action1 = JAction.Create()
    .Do(static () => Debug.Log("同步"))
    .Execute();

// 异步执行带自动释放（推荐）
using var action2 = await JAction.Create()
    .Do(static () => Debug.Log("异步"))
    .Delay(1f)
    .ExecuteAsync();

// 两个 action 都会自动被释放并返回池中
```

这等同于手动调用 `Dispose()`，但更安全、更简洁 - 即使发生异常也会正确释放。

### 帧延迟

- **`ExecuteAsync()`**：`.DelayFrame()` 等待实际的 Unity 帧
- **`Execute()`**：`.DelayFrame()` 被转换为基于时间的延迟（阻塞模式下帧不会推进）

### 超时行为

- `timeout = 0` 表示无超时（无限等待）
- 当达到超时时，执行停止并调用 `OnCancel` 回调

### 抢占点

JAction 在以下抢占点检查取消和超时：
- 每个 `.Delay()` / `.DelayFrame()` 前后
- `.WaitUntil()` / `.WaitWhile()` 的每次迭代
- `.Repeat*()` 循环的每次迭代
- 并行操作之间

`.Do()` 回调内的代码以原子方式运行，无法在执行中途被抢占。

## 流畅 API 参考

### 动作执行

| 方法 | 描述 |
|------|------|
| `.Do(Action)` | 执行同步动作 |
| `.Do(Action<T>, T)` | 执行带状态参数的动作（零GC） |
| `.Do(Func<JActionAwaitable>)` | 执行异步动作 |
| `.Do(Func<T, JActionAwaitable>, T)` | 执行带状态参数的异步动作 |

### 延迟

| 方法 | 描述 |
|------|------|
| `.Delay(float)` | 等待指定秒数 |
| `.DelayFrame(int)` | 等待指定帧数 |

### 条件等待

| 方法 | 描述 |
|------|------|
| `.WaitUntil(Func<bool>)` | 等待直到条件返回 true |
| `.WaitUntil(Func<T, bool>, T)` | 带状态参数的条件等待 |
| `.WaitWhile(Func<bool>)` | 当条件为 true 时等待 |
| `.WaitWhile(Func<T, bool>, T)` | 带状态参数的条件等待 |

### 循环

| 方法 | 描述 |
|------|------|
| `.Repeat(Action, int, float)` | 重复动作 N 次，带间隔 |
| `.Repeat(Action<T>, T, int, float)` | 带状态参数的重复 |
| `.RepeatWhile(Action, Func<bool>, float, float)` | 当条件为 true 时重复动作 |
| `.RepeatWhile(Action<T>, Func<T,bool>, T, float, float)` | 带状态参数的条件重复 |
| `.RepeatUntil(Action, Func<bool>, float, float)` | 重复动作直到条件变为 true |
| `.RepeatUntil(Action<T>, Func<T,bool>, T, float, float)` | 带状态参数的条件重复 |

### 并行模式

| 方法 | 描述 |
|------|------|
| `.Parallel()` | 为后续动作启用并行执行 |

### 取消

| 方法 | 描述 |
|------|------|
| `.OnCancel(Action)` | 注册取消回调 |
| `.OnCancel(Action<T>, T)` | 带状态参数的取消回调 |

## 零GC状态重载

闭包（捕获变量的 lambda）会导致堆分配和 GC 压力。JAction 提供状态重载来避免这个问题。

### 为什么闭包会分配内存

```csharp
// 不好：闭包捕获 'player'，每次调用都会分配内存
Player player = GetPlayer();
JAction.Create()
    .Do(() => player.TakeDamage(10))  // 会分配内存！
    .Execute();
```

### 使用状态重载

```csharp
// 好：静态 lambda + 状态参数 + using = 零分配
Player player = GetPlayer();
using var action = JAction.Create()
    .Do(static (p) => p.TakeDamage(10), player)  // 无闭包分配！
    .Execute();
// JAction 返回池中，无残留分配
```

<Callout type="warn" title="重要限制">
状态重载**仅适用于引用类型**（类、数组等）。

状态重载**不适用于值类型**（int、float、struct、bool 等），因为值类型作为泛型参数传递时会被装箱，这违背了避免分配的目的。
</Callout>

### 示例

```csharp
// 引用类型 - 使用状态重载（零分配）
MyClass obj = new MyClass();
using var action1 = JAction.Create()
    .Do(static (o) => o.DoSomething(), obj)
    .Execute();

// 值类型 - 状态重载无法正常工作
int myValue = 42;
using var action2 = JAction.Create()
    .Do(static (v) => Debug.Log(v), myValue)  // 不要这样做 - 值会被装箱
    .Execute();

// 值类型 - 改用闭包
int myValue2 = 42;
using var action3 = JAction.Create()
    .Do(() => Debug.Log(myValue2))  // 可以 - 这里闭包是可接受的
    .Execute();
```

### 支持状态重载的方法

以下所有方法都有零GC的状态重载：
- `Do<T>(Action<T>, T)`
- `Do<T>(Func<T, JActionAwaitable>, T)`
- `WaitUntil<T>(Func<T, bool>, T, float, float)`
- `WaitWhile<T>(Func<T, bool>, T, float, float)`
- `RepeatWhile<T>(Action<T>, Func<T, bool>, T, float, float)`
- `RepeatUntil<T>(Action<T>, Func<T, bool>, T, float, float)`
- `Repeat<T>(Action<T>, T, int, float)`
- `OnCancel<T>(Action<T>, T)`

## 零GC异步执行

JAction 通过自定义 awaitable 类型提供真正的零GC异步执行。

### 自定义 Awaitable 类型

- **`JActionAwaitable`** - 自定义 awaitable 结构体（不是 Task/UniTask）
- **`JActionAwaiter`** - 自定义 awaiter 结构体

两者都是**结构体**，这意味着使用 async/await 时不会产生堆分配。

### 异步用法

```csharp
// 零GC异步执行，带自动释放
using var action = await JAction.Create()
    .Do(static () => Debug.Log("开始"))
    .Delay(1f)
    .Do(static () => Debug.Log("1秒后"))
    .Delay(1f)
    .Do(static () => Debug.Log("完成"))
    .ExecuteAsync(timeout: 5f);
```

### 与状态重载结合

要实现**真正的零GC异步执行**，请将 `ExecuteAsync()` 与状态重载结合使用：

```csharp
GameManager gm = GetGameManager();

using var action = await JAction.Create()
    .Do(static (g) => g.StartLoading(), gm)
    .WaitUntil(static (g) => g.IsLoaded, gm)
    .Do(static (g) => g.StartGame(), gm)
    .ExecuteAsync(timeout: 30f);
```

## 生命周期管理

### 方法

| 方法 | 描述 |
|------|------|
| `Cancel()` | 取消当前执行 |
| `Reset()` | 重置 JAction 状态以便重用 |
| `Dispose()` | 将 JAction 实例返回池中 |

### 对象池

JAction 实例会自动被池化（最多 32 个实例）以减少分配：

```csharp
// 检查池状态
int pooled = JAction.PooledCount;

// 如有需要清空池
JAction.ClearPool();
```

### 最佳实践：使用 `using` 自动释放

```csharp
// 推荐：using 模式确保即使发生异常也能正确释放
using var action = await JAction.Create()
    .Do(static () => Debug.Log("工作"))
    .Delay(1f)
    .ExecuteAsync();

// action 自动被释放并返回池中
```

手动释放（如果不使用 `using`）：

```csharp
var action = JAction.Create()
    .Do(static () => Debug.Log("工作"))
    .Delay(1f);

await action.ExecuteAsync();

// 必须手动返回池中
action.Dispose();
```

## 实际示例

<Tabs items={['加载序列', '重试逻辑', '动画序列']}>
<Tab value="加载序列">
```csharp
LoadingUI ui = GetLoadingUI();

using var action = await JAction.Create()
    .Do(static (u) => u.Show(), ui)
    .Do(static (u) => u.SetProgress(0), ui)
    .Delay(0.5f)
    .Do(static (u) => u.SetProgress(0.3f), ui)
    .Delay(0.5f)
    .Do(static (u) => u.SetProgress(0.7f), ui)
    .Delay(0.5f)
    .Do(static (u) => u.SetProgress(1f), ui)
    .Delay(0.3f)
    .Do(static (u) => u.Hide(), ui)
    .ExecuteAsync();
```
</Tab>
<Tab value="重试逻辑">
```csharp
NetworkManager net = GetNetworkManager();

using var action = await JAction.Create()
    .RepeatUntil(
        static (n) => n.TryConnect(),   // 要重复的操作
        static (n) => n.IsConnected,    // 连接成功时停止
        net,                            // 状态
        frequency: 1f                   // 每1秒重试一次
    )
    .Do(static (n) => n.OnConnected(), net)
    .OnCancel(static (n) => n.OnFailed(), net)
    .ExecuteAsync(timeout: 10f);
```
</Tab>
<Tab value="动画序列">
```csharp
Transform target = GetTarget();

using var action = await JAction.Create()
    .Do(static (t) => t.localScale = Vector3.zero, target)
    .Do(static (t) => t.gameObject.SetActive(true), target)
    .Delay(0.1f)
    .Do(static (t) => t.localScale = Vector3.one * 1.2f, target)
    .Delay(0.1f)
    .Do(static (t) => t.localScale = Vector3.one, target)
    .ExecuteAsync();
```
</Tab>
</Tabs>

## 最佳实践

<Accordions>
<Accordion title="优先使用 ExecuteAsync() 而非 Execute()">
同步执行通过自旋阻塞主线程，导致掉帧和 UI 冻结。仅在单元测试或编辑器脚本中使用 `Execute()`。
</Accordion>

<Accordion title="使用 static lambda 配合状态参数">
在性能关键代码中使用静态 lambda 配合状态参数，以避免闭包导致的 GC 分配。
</Accordion>

<Accordion title="保持 .Do() 回调轻量">
回调内的代码以原子方式运行，无法被抢占。长时间运行或阻塞的操作会冻结游戏。
</Accordion>

<Accordion title="使用 using 模式">
自动释放并将 JAction 实例返回池中：`using var action = await ...ExecuteAsync()`
</Accordion>

<Accordion title="设置适当的超时时间">
防止生产环境中的无限等待，设置合理的超时值。
</Accordion>

<Accordion title="状态重载仅适用于引用类型">
对于值类型（int、float、struct），请使用闭包或封装到类中。
</Accordion>
</Accordions>
